import ctypes as ct
from caen_libs import _utils
from enum import IntEnum
from typing import Any, Tuple, Type, Union

class ErrorCode(IntEnum):
    OK: int = ...
    GENERIC: int = ...
    INTERFACE: int = ...
    FPGA: int = ...
    TRANSFER_MAX_LENGTH: int = ...
    NOTCONNECTED: int = ...
    NO_DATA_AVAILABLE: int = ...
    TOO_MANY_DEVICES_CONNECTED: int = ...
    INVALID_HANDLE: int = ...
    INVALID_HARDWARE: int = ...
    INVALID_PARAMETERS: int = ...
    TERMINATED: int = ...

class ConnectionModes(IntEnum):
    DIRECT_USB: int = ...
    DIRECT_ETH: int = ...
    VME_V1718: int = ...
    VME_V2718: int = ...
    VME_V4718_ETH: int = ...
    VME_V4718_USB: int = ...
    VME_A4818: int = ...

class FPGA(IntEnum):
    MAIN: int = ...
    USER: int = ...
    DELAY: int = ...

class _USBDeviceRaw(ct.Structure): ...

class USBDevice(ct.Structure):
    id: int
    sn: str
    desc: str
    def __init__(self, id: Any, sn: Any, desc: Any) -> None: ...

class _BoardInfoRaw(ct.Structure): ...

class BoardInfo(ct.Structure):
    checksum: int
    checksum_length2: int
    checksum_length1: int
    checksum_length0: int
    checksum_constant2: int
    checksum_constant1: int
    checksum_constant0: int
    c_code: int
    r_code: int
    oui2: int
    oui1: int
    oui0: int
    version: int
    board2: int
    board1: int
    board0: int
    revis3: int
    revis2: int
    revis1: int
    revis0: int
    reserved: Tuple[int, ...]
    sernum1: int
    sernum0: int
    def __init__(self, checksum: Any, checksum_length2: Any, checksum_length1: Any, checksum_length0: Any, checksum_constant2: Any, checksum_constant1: Any, checksum_constant0: Any, c_code: Any, r_code: Any, oui2: Any, oui1: Any, oui0: Any, version: Any, board2: Any, board1: Any, board0: Any, revis3: Any, revis2: Any, revis1: Any, revis0: Any, reserved: Any, sernum1: Any, sernum0: Any) -> None: ...

class Error(RuntimeError):
    code: ErrorCode
    message: str
    func: str
    def __init__(self, message: str, res: int, func: str) -> None: ...

class _Lib(_utils.Lib):
    def __init__(self, name: str) -> None: ...
    def decode_error(self, error_code: int) -> str: ...
    def usb_enumerate(self) -> Tuple[USBDevice, ...]: ...
    def usb_enumerate_serial_number(self) -> str: ...

lib: _Lib

class Device:
    handle: int
    opened: bool = ...
    connection_mode: ConnectionModes = ...
    arg: Union[int, str] = ...
    conet_node: int = ...
    vme_base_address: str = ...
    def __del__(self) -> None: ...
    @classmethod
    def open(cls: Type[_T], connection_mode: ConnectionModes, arg: Union[int, str], conet_node: int, vme_base_address: Union[int, str]) -> _T: ...
    def connect(self) -> None: ...
    def close(self) -> None: ...
    def write_reg(self, address: int, value: int) -> None: ...
    def read_reg(self, address: int) -> int: ...
    def enable_flash_access(self, fpga: FPGA) -> None: ...
    def disable_flash_access(self, fpga: FPGA) -> None: ...
    def delete_flash_sector(self, fpga: FPGA, sector: int) -> None: ...
    def write_flash_data(self, fpga: FPGA, address: int, data: bytes) -> None: ...
    def read_flash_data(self, fpga: FPGA, address: int, length: int) -> bytes: ...
    def get_serial_number(self) -> str: ...
    def get_info(self) -> BoardInfo: ...
    def device_closed(self) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> None: ...
    def __init__(self, handle: Any, opened: Any, connection_mode: Any, arg: Any, conet_node: Any, vme_base_address: Any) -> None: ...
